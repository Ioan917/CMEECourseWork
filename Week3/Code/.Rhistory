for (pop in 2:100) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(1000,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, length(p0)) # creates a vector of NA
N[1,] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:100) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, length(p0)) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:100) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(1000,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, length(p0)) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, length(p0)) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, 1000) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrick())
stochrick<-function(
p0 = runif(1000,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, length(p0)) # creates a vector of NA
N[1,] <- p0
for (pop in 1:length(p0)){ # loop through the populations
for (yr in 2:numyears){ # for each pop, loop through the years
N[yr,pop] <- N[yr-1,pop] * exp(r * (1 - N[yr - 1,pop] / K) + rnorm(1,0,sigma))
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[, 1] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
print("Non-vectorized Stochastic Ricker takes:")
print(system.time(normal<-stochrick()))
print("Vectorized Stochastic Ricker takes:")
print(system.time(vect<-stochrickvect()))
print("Script done!")
stochrickvect<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, 1000) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrickvect())
print("Non-vectorized Stochastic Ricker takes:")
print(system.time(normal<-stochrick()))
print("Vectorized Stochastic Ricker takes:")
print(system.time(vect<-stochrickvect()))
print("Script done!")
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
print(system.time(normal<-stochrick()))
print("Non-vectorized Stochastic Ricker takes:")
print("Vectorized Stochastic Ricker takes:")
print(system.time(vect<-stochrickvect()))
stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
return(N)
}
plot(stochrickvect(()))
plot(stochrickvect(())
plot(stochrickvect())
stochrickvect<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, 1000) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrickvect())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
set.seed(1)
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick())
stochrickvect<-function(
p0 = runif(100,.5,1.5),
r = 1.2, # intrinsic growth rate
K = 1, # carrying capacity
sigma = 0.2,
numyears = 100) {
#initialize
N <- matrix(NA, numyears, 1000) # creates a vector of NA
N[, 1] <- p0
sig <- replicate(length(p0), rnorm(1, 0, sigma))
for (pop in 2:1000) {
N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
}
return(N)
}
plot(stochrickvect())
stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
return(N)
}
plot(stockrickvect( ))
plot(stockrickvect())
plot(stochrickvect())
#!/usr/bin/env R
set.seed(1)
# Runs the stochastic Ricker equation with gaussian fluctuations
rm(list=ls())
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
# Now write another function called stochrickvect that vectorizes the above
# to the extent possible, with improved performance:
stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
return(N)
}
print("Non-vectorized Stochastic Ricker takes:")
print(system.time(normal<-stochrick()))
print("Vectorized Stochastic Ricker takes:")
print(system.time(vect<-stochrickvect()))
print("Script done!")
##### ALTERNATIVE IDEA #####
#stochrickvect<-function(
#  p0 = runif(100,.5,1.5),
#  r = 1.2, # intrinsic growth rate
#  K = 1, # carrying capacity
#  sigma = 0.2,
#  numyears = 100) {
#
#  #initialize
#  N <- matrix(NA, numyears, 1000) # creates a vector of NA
#  N[, 1] <- p0
#  sig <- replicate(length(p0), rnorm(1, 0, sigma))
#
#  for (pop in 2:1000) {
#
#    N[,pop] <- N[, pop - 1] * exp(r * (1 - N[, pop - 1] / K) + rnorm(1,0,sigma))
#
#  }
#
#  return(N)
#
#}
dev.off()
rm(list=ls())
setwd("~/Documents/CMEECourseWork/Week3/Code")
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- MyData %>%
tibble::rownames_to_column() %>%
pivot_longer(-rowname) %>%
pivot_wider(names_from=rowname, values_from=value)
library(tidyverse)
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- read_csv("../Data/PoundHillData.csv", col_names = FALSE)
# header = true because we do have metadata headers
MyMetaData <- read_csv2("../Data/PoundHillMetaData.csv", col_names = TRUE)
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- MyData %>%
tibble::rownames_to_column() %>%
pivot_longer(-rowname) %>%
pivot_wider(names_from=rowname, values_from=value)
############# Replace species absences with zeros ###############
MyData <- MyData %>% replace(is.na(.), 0)
# Remove first column
MyData <- MyData[, -1]
# Make first row the header
names(MyData) <- as.matrix(MyData[1, ])
MyData <- MyData[-1, ]
MyData[] <- lapply(MyData, function(x) type.convert(as.character(x)))
MyWrangledData <- gather(MyData, key = "Species", value = "Count", factor_key = FALSE, -Cultivation, -Block, -Plot, -Quadrat)
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
class(MyWrangledData)
MyWrangledData[, "Cultivation"] <- as_factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as_factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as_factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as_factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as_integer(MyWrangledData[, "Count"])
MyWrangledData[, "Count"] <- as_int(MyWrangledData[, "Count"])
MyWrangledData[, "Count"] <- as.int(MyWrangledData[, "Count"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################
library(tidyverse)
############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- read_csv("../Data/PoundHillData.csv", col_names = FALSE)
# header = true because we do have metadata headers
MyMetaData <- read_csv2("../Data/PoundHillMetaData.csv", col_names = TRUE)
############# Inspect the dataset ###############
dplyr::slice(MyData, 1:5)
dplyr::glimpse(MyData)
utils::View(MyData)
utils::View(MyMetaData)
############# Transpose ###############
# To get those species into columns and treatments into rows
MyData <- MyData %>%
tibble::rownames_to_column() %>%
pivot_longer(-rowname) %>%
pivot_wider(names_from=rowname, values_from=value)
dplyr::slice(MyData, 1:5)
############# Replace species absences with zeros ###############
MyData <- MyData %>% replace(is.na(.), 0)
############# Convert raw matrix to data frame ###############
# Remove first column
MyData <- MyData[, -1]
# Make first row the header
names(MyData) <- as.matrix(MyData[1, ])
MyData <- MyData[-1, ]
MyData[] <- lapply(MyData, function(x) type.convert(as.character(x)))
############# Convert from wide to long format  ###############
# use gather() from tidyr
MyWrangledData <- gather(MyData, key = "Species", value = "Count", factor_key = FALSE, -Cultivation, -Block, -Plot, -Quadrat)
MyWrangledData[, "Cultivation"] <- as_factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as_factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as_factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as_factor(MyWrangledData[, "Quadrat"])
dplyr::slice(MyData, 1:5)
############# Exploring the data (extend the script below)  ###############
dplyr::slice(MyWrangledData, 1:5)
MyWrangledData[, "Plot"] <- as_factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Plot"] <- as_character(MyWrangledData[, "Plot"])
MyWrangledData[, "Plot"] <- as_integer(MyWrangledData[, "Plot"])
MyWrangledData[, "Plot"] <- as_factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as_factor(MyWrangledData[, "Quadrat"])
rm(list=ls())
library(maps)
## Load data
load("../Data/GPDDFiltered.RData")
## Create world map
map(database = "world")
points(gpdd$long, gpdd$lat, pch =  3, cex = 0.5, col = "blue")
map.axes()
print("Script done!")
dev.off()
rm(list=ls())
stochrickvect <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, ] <- N[yr-1, ] * exp(r * (1 - N[yr - 1, ] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
return(N)
}
plot(stochrickvect(generations=10), type="l")
plot(stochrickvect(numyears = 10), type="l")
stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears=100) {
N <- matrix(NA, numyears, length(p0))  #initialize empty matrix
N[1, ] <- p0
for (pop in 1:length(p0)){ #loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K) + rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
}
}
return(N)
}
plot(stochrick(numyears = 10), type="l")
rm(list=ls())
dev.off()
install.packages("sqldf")
print("The correlation of ", corr_1, "has a p-value of", pvalue)
corr_1 <- cor(ats$Temp[-100], ats$Temp[-1]) #  0.3261697
data <- load("../Data/KeyWestAnnualMeanTemperature.RData")
corr_1 <- cor(ats$Temp[-100], ats$Temp[-1]) #  0.3261697
corr_dist <- replicate(10000, {
permute <- sample(ats$Temp)
corr <- cor(permute[-100], permute[-1])
})
pvalue <- sum(corr_dist > corr_1) / length(corr_dist)
print("The correlation of ", corr_1, "has a p-value of", pvalue)
print("The correlation of " + as.character(corr_1), "has a p-value of", as.character(pvalue))
print("The correlation of " + as.character(corr_1) + "has a p-value of" + as.character(pvalue))
print(paste("The correlation of " + as.character(corr_1) + "has a p-value of" + as.character(pvalue)))
print(paste("The correlation of ", as.character(corr_1), "has a p-value of", as.character(pvalue)))
print(paste("The correlation of ", as.character(signif(corr_1, digits = 3)), "has a p-value of", as.character(pvalue)))
print(paste("The correlation of ", as.character(signif(corr_1, digits = 3)), "has a p-value of", as.character(pvalue)))
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue)) + ".")
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue)), ".")
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue)), ".")
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue)))
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue) + "."))
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue), "."))
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue), "."), sep = '')
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue), "."), sep = '  ')
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue), "."), separate() = "")
print(paste("The correlation of", as.character(signif(corr_1, digits = 3)),
"returns a p-value of", as.character(pvalue), ".", sep = ""))
print(paste("The correlation of ", as.character(signif(corr_1, digits = 3)),
" returns a p-value of ", as.character(pvalue), ".", sep = ""))
print(paste("t and t-1 have a correlation of ", as.character(signif(corr_1, digits = 3)),
" which returns a p-value of ", as.character(pvalue), ".", sep = ""))
print(paste("t and t-1 have a correlation of ", as.character(signif(corr_1, digits = 3)),
", which returns a p-value of ", as.character(pvalue), ".", sep = ""))
